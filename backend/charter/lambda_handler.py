"""
Chart Maker Agent Lambda Handler
"""

import os
import json
import asyncio
import logging
from typing import Dict, Any

from agents import Agent, Runner, trace
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
from litellm.exceptions import RateLimitError

try:
    from dotenv import load_dotenv
    load_dotenv(override=True)
except ImportError:
    pass

# Import database package
from src import Database

from templates import CHARTER_INSTRUCTIONS, CHARTER_RETRY_INSTRUCTIONS
from agent import create_agent
from observability import observe

VALID_CHART_TYPES = {"pie", "bar", "donut", "horizontalBar"}


def validate_charts(parsed_data: dict) -> tuple[list, str]:
    """Validate parsed JSON has a valid charts array with required fields.

    Returns (charts_list, error_message). error_message is empty on success.
    """
    if not isinstance(parsed_data, dict):
        return [], "Parsed data is not a JSON object"

    charts = parsed_data.get("charts")
    if not isinstance(charts, list) or len(charts) == 0:
        return [], "Missing or empty 'charts' array"

    for i, chart in enumerate(charts):
        if not isinstance(chart, dict):
            return [], f"Chart {i} is not an object"
        missing = [f for f in ("key", "title", "type", "data") if f not in chart]
        if missing:
            return [], f"Chart {i} missing fields: {missing}"
        if chart["type"] not in VALID_CHART_TYPES:
            return [], f"Chart {i} has invalid type '{chart['type']}'"
        if not isinstance(chart["data"], list) or len(chart["data"]) == 0:
            return [], f"Chart {i} has empty or invalid data array"

    return charts, ""

logger = logging.getLogger()
logger.setLevel(logging.INFO)

@retry(
    retry=retry_if_exception_type(RateLimitError),
    stop=stop_after_attempt(5),
    wait=wait_exponential(multiplier=1, min=4, max=60),
    before_sleep=lambda retry_state: logger.info(f"Charter: Rate limit hit, retrying in {retry_state.next_action.sleep} seconds...")
)
async def run_charter_agent(job_id: str, portfolio_data: Dict[str, Any], db=None, technical_data: Dict[str, Any] = None) -> Dict[str, Any]:
    """Run the charter agent to generate visualization data."""

    # Create agent without tools - will output JSON
    model, task = create_agent(job_id, portfolio_data, db, technical_data)

    def _parse_charts_output(output: str) -> tuple[dict | None, str]:
        """Extract and validate charts JSON from agent output.

        Returns (charts_data_dict, error_reason). charts_data_dict is None on failure.
        """
        if not output:
            return None, "Agent returned empty output"

        start_idx = output.find('{')
        end_idx = output.rfind('}')

        if start_idx < 0 or end_idx <= start_idx:
            return None, f"No JSON structure found in output: {output[:300]}"

        json_str = output[start_idx:end_idx + 1]
        logger.info(f"Charter: Extracted JSON substring, length: {len(json_str)}")

        try:
            parsed_data = json.loads(json_str)
        except json.JSONDecodeError as e:
            return None, f"JSON parse error: {e} — raw: {json_str[:300]}"

        charts, validation_error = validate_charts(parsed_data)
        if validation_error:
            return None, f"Schema validation failed: {validation_error}"

        # Build the charts_payload with chart keys as top-level keys
        charts_data = {}
        for chart in charts:
            chart_key = chart.get('key', f"chart_{len(charts_data) + 1}")
            chart_copy = {k: v for k, v in chart.items() if k != 'key'}
            charts_data[chart_key] = chart_copy

        return charts_data, ""

    # --- Attempt 1: normal run ---
    with trace("Charter Agent"):
        agent = Agent(
            name="Chart Maker",
            instructions=CHARTER_INSTRUCTIONS,
            model=model
        )

        result = await Runner.run(
            agent,
            input=task,
            max_turns=5
        )

        output = result.final_output
        logger.info(f"Charter: Agent completed, output length: {len(output) if output else 0}")
        if output:
            logger.info(f"Charter: Output preview (first 1000 chars): {output[:1000]}")
        else:
            logger.warning("Charter: Agent returned empty output!")

        charts_data, error_reason = _parse_charts_output(output)

    # --- Attempt 2: retry with stricter prompt if first attempt failed ---
    if charts_data is None:
        logger.warning(f"Charter: First attempt failed — {error_reason}. Retrying with stricter prompt.")

        with trace("Charter Agent Retry"):
            retry_agent = Agent(
                name="Chart Maker Retry",
                instructions=CHARTER_RETRY_INSTRUCTIONS,
                model=model
            )

            retry_input = f"{task}\n\nPREVIOUS FAILED OUTPUT (do not repeat this mistake):\n{(output or '')[:500]}"
            retry_result = await Runner.run(
                retry_agent,
                input=retry_input,
                max_turns=5
            )

            retry_output = retry_result.final_output
            logger.info(f"Charter: Retry output length: {len(retry_output) if retry_output else 0}")
            if retry_output:
                logger.info(f"Charter: Retry preview: {retry_output[:1000]}")

            charts_data, retry_error = _parse_charts_output(retry_output)
            if charts_data is None:
                logger.error(f"Charter: Retry also failed — {retry_error}")

    # --- Save to database ---
    charts_saved = False
    if db and charts_data:
        try:
            success = db.jobs.update_charts(job_id, charts_data)
            charts_saved = bool(success)
            logger.info(f"Charter: Database update returned: {success}, keys: {list(charts_data.keys())}")
        except Exception as e:
            logger.error(f"Charter: Database error: {e}")
    elif db and charts_data is None:
        # Save diagnostic error so frontend can show a message
        diagnostic = {"_error": {"message": "Chart generation failed after retry", "reason": error_reason}}
        try:
            db.jobs.update_charts(job_id, diagnostic)
            logger.info("Charter: Saved diagnostic error to charts_payload")
        except Exception as e:
            logger.error(f"Charter: Failed to save diagnostic: {e}")

    return {
        'success': charts_saved,
        'message': f'Generated {len(charts_data)} charts' if charts_saved else 'Failed to generate charts',
        'charts_generated': len(charts_data) if charts_data else 0,
        'chart_keys': list(charts_data.keys()) if charts_data else []
    }

def lambda_handler(event, context):
    """
    Lambda handler expecting job_id and portfolio_data in event.

    Expected event:
    {
        "job_id": "uuid",
        "portfolio_data": {...}
    }
    """
    # Wrap entire handler with observability context
    with observe():
        try:
            logger.info(f"Charter Lambda invoked with event keys: {list(event.keys()) if isinstance(event, dict) else 'not a dict'}")

            # Parse event
            if isinstance(event, str):
                event = json.loads(event)

            job_id = event.get('job_id')
            if not job_id:
                return {
                    'statusCode': 400,
                    'body': json.dumps({'error': 'job_id is required'})
                }

            # Initialize database first
            db = Database()

            portfolio_data = event.get('portfolio_data')
            if not portfolio_data:
                # Load portfolio data from database (like Reporter does)
                logger.info(f"Charter: Loading portfolio data for job {job_id}")
                try:
                    job = db.jobs.find_by_id(job_id)
                    if job:
                        user_id = job['clerk_user_id']
                        user = db.users.find_by_clerk_id(user_id)
                        accounts = db.accounts.find_by_user(user_id)

                        portfolio_data = {
                            'user_id': user_id,
                            'job_id': job_id,
                            'years_until_retirement': user.get('years_until_retirement', 30) if user else 30,
                            'accounts': []
                        }

                        for account in accounts:
                            account_data = {
                                'id': account['id'],
                                'name': account['account_name'],
                                'type': account.get('account_type', 'investment'),
                                'cash_balance': float(account.get('cash_balance', 0)),
                                'positions': []
                            }

                            positions = db.positions.find_by_account(account['id'])
                            for position in positions:
                                instrument = db.instruments.find_by_symbol(position['symbol'])
                                if instrument:
                                    account_data['positions'].append({
                                        'symbol': position['symbol'],
                                        'quantity': float(position['quantity']),
                                        'instrument': instrument
                                    })

                            portfolio_data['accounts'].append(account_data)

                        logger.info(f"Charter: Loaded {len(portfolio_data['accounts'])} accounts with positions")
                    else:
                        logger.error(f"Charter: Job {job_id} not found")
                        return {
                            'statusCode': 404,
                            'body': json.dumps({'error': 'Job not found'})
                        }
                except Exception as e:
                    logger.error(f"Charter: Error loading portfolio data: {e}")
                    return {
                        'statusCode': 500,
                        'body': json.dumps({'error': f'Failed to load portfolio data: {str(e)}'})
                    }

            logger.info(f"Charter: Processing job {job_id}")

            # Load technical indicators from DB (populated by Planner)
            technical_data = {}
            try:
                symbols = set()
                for account in portfolio_data.get("accounts", []):
                    for position in account.get("positions", []):
                        if position.get("symbol"):
                            symbols.add(position["symbol"])
                if symbols:
                    records = db.technical_indicators.find_by_symbols(list(symbols))
                    for r in records:
                        ind = r.get("indicators")
                        if isinstance(ind, str):
                            ind = json.loads(ind)
                        technical_data[r["symbol"]] = ind
                    logger.info(f"Charter: Loaded technical indicators for {len(technical_data)} symbols")
            except Exception as e:
                logger.warning(f"Charter: Could not load technical indicators: {e}")

            # Run the agent
            result = asyncio.run(run_charter_agent(job_id, portfolio_data, db, technical_data))

            logger.info(f"Charter completed for job {job_id}: {result}")

            return {
                'statusCode': 200,
                'body': json.dumps(result)
            }

        except Exception as e:
            logger.error(f"Error in charter: {e}", exc_info=True)
            return {
                'statusCode': 500,
                'body': json.dumps({
                    'success': False,
                    'error': str(e)
                })
            }

# For local testing
if __name__ == "__main__":
    test_event = {
        "job_id": "550e8400-e29b-41d4-a716-446655440001",
        "portfolio_data": {
            "accounts": [
                {
                    "id": "acc1",
                    "name": "401(k)",
                    "type": "401k",
                    "cash_balance": 5000,
                    "positions": [
                        {
                            "symbol": "SPY",
                            "quantity": 100,
                            "instrument": {
                                "name": "SPDR S&P 500 ETF",
                                "current_price": 450,
                                "allocation_asset_class": {"equity": 100},
                                "allocation_regions": {"north_america": 100},
                                "allocation_sectors": {"technology": 30, "healthcare": 15, "financials": 15, "consumer_discretionary": 20, "industrials": 20}
                            }
                        }
                    ]
                }
            ]
        }
    }
    
    result = lambda_handler(test_event, None)
    print(json.dumps(result, indent=2))